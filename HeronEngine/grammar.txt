AccumulateExpr ::== (accumulate + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + Initializer + forall + EOW + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + in + EOW + WS + DelayedExpr + ) + WS + DelayedExpr)
Annotations ::== ([ + WS + (CompoundExpr + (, + WS + CompoundExpr)*)? + ] + WS)
AnyChar ::== .
AnyCharExceptEndOfLine ::== (LineExt | (EndOfLine^ + AnyChar))
ArgList ::== (( + WS + (Param + (, + WS + Param)*)? + ) + WS)
BasicExpr ::== (NewExpr | MapExpr | SelectExpr | AccumulateExpr | ReduceExpr | FunExpr | TableExpr | RecordExpr | SpecialName | Name | Literal | ParanthesizedExpr | BracketedExpr)
BinaryDigit ::== [01]
BinaryLiteral ::== (0b + BinaryValue)
BinaryValue ::== BinaryDigit+
BlockComment ::== (/* + (*/^ + AnyChar)* + */)
BracketedExpr ::== ([ + WS + (DelayedExpr + (, + WS + DelayedExpr)*)? + ] + WS)
CaseGroup ::== CaseStatement*
CaseStatement ::== (case + EOW + WS + ParanthesizedExpr + CodeBlock)
CharLiteral ::== (['] + StringCharLiteral + ['])
Class ::== (Annotations? + class + EOW + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + ClassBody)
ClassBody ::== ({ + WS + Inherits? + Implements? + Fields? + Methods? + } + WS)
CodeBlock ::== ({ + WS + DelayedStatement* + } + WS)
Comment ::== (BlockComment | LineComment)
CompoundExpr ::== BasicExpr+
DefaultStatement ::== (default + EOW + WS + CodeBlock)
DelayedBasicExpr ::== basicexpr
DelayedExpr ::== expr
DelayedStatement ::== Statement
DeleteStatement ::== (delete + EOW + WS + CompoundExpr + ; + WS)
Digit ::== [0..9]
ElseStatement ::== (else + EOW + WS + DelayedStatement)
EmptyMethod ::== (FunDecl + ; + WS)
EmptyMethods ::== (methods + EOW + WS + { + WS + EmptyMethod* + } + WS)
EmptyStatement ::== Eos
EndOfInput ::== _eof_
EndOfLine ::== (\r\n | \n\r | \n)
Enum ::== (Annotations? + enum + EOW + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + EnumValues)
EnumValue ::== (Name + Eos)
EnumValues ::== ({ + WS + EnumValue* + } + WS)
Eos ::== (; + WS)
EOSOrCodeBlock ::== (Eos | CodeBlock)
EOW ::== IdentNextChar^
EscapeChar ::== ([\] + AnyChar)
ExprStatement ::== (CompoundExpr + Eos)
Field ::== (Annotations? + Name + TypeDecl? + Initializer? + Eos)
Fields ::== (fields + EOW + WS + { + WS + Field* + } + WS)
File ::== (Module + EndOfInput)
FloatLiteral ::== ([-]? + Digit+ + [.] + Digit+)
ForEachParams ::== (( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + TypeDecl? + in + EOW + WS + CompoundExpr + ) + WS)
ForEachStatement ::== (foreach + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + TypeDecl? + in + EOW + WS + CompoundExpr + ) + WS + DelayedStatement)
ForParams ::== (( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + = + WS + CompoundExpr + ; + WS + CompoundExpr + ; + WS + CompoundExpr + ) + WS)
ForStatement ::== (for + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + = + WS + CompoundExpr + ; + WS + CompoundExpr + ; + WS + CompoundExpr + ) + WS + DelayedStatement)
FunDecl ::== (Name + ArgList + TypeDecl?)
FunExpr ::== (function + EOW + WS + ArgList + TypeDecl? + CodeBlock)
HexDigit ::== (Digit | [a..f] | [A..F])
HexLiteral ::== (0x + HexValue)
HexValue ::== HexDigit+
Ident ::== (IdentFirstChar + IdentNextChar*)
IdentFirstChar ::== ([_] | Letter)
IdentNextChar ::== (IdentFirstChar | Digit)
IfStatement ::== (if + EOW + WS + ParanthesizedExpr + DelayedStatement + ElseStatement?)
Implements ::== (implements + EOW + WS + { + WS + (TypeExpr + ; + WS)* + } + WS)
Import ::== (Name + = + WS + new + EOW + WS + (Ident + (. + WS + IdentFirstChar + IdentNextChar*)*) + WS + ParanthesizedExpr + ; + WS)
Imports ::== (imports + EOW + WS + { + WS + Import* + } + WS)
Inherits ::== (inherits + EOW + WS + { + WS + (TypeExpr + ; + WS)* + } + WS)
Initializer ::== (= + WS + CompoundExpr)
IntegerLiteral ::== ([-]? + Digit+)
Interface ::== (Annotations? + interface + EOW + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + { + WS + Inherits? + EmptyMethods? + } + WS)
Letter ::== (LowerCaseLetter | UpperCaseLetter)
LineComment ::== (// + UntilEndOfLine)
LineExt ::== (\ + EndOfLine)
Literal ::== ((VerbStringLiteral | StringLiteral | CharLiteral | NumLiteral) + WS)
LowerCaseLetter ::== [a..z]
MapExpr ::== (map + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + in + EOW + WS + DelayedExpr + ) + WS + DelayedExpr)
Method ::== (Annotations? + FunDecl + CodeBlock)
Methods ::== (methods + EOW + WS + { + WS + Method* + } + WS)
Module ::== (Annotations? + module + EOW + WS + (Ident + (. + WS + IdentFirstChar + IdentNextChar*)*) + WS + ModuleBody + TypeDefinition*)
ModuleBody ::== ({ + WS + Imports? + Fields? + Methods? + } + WS)
Name ::== ((SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS)
NewExpr ::== (new + EOW + WS + TypeExpr + ParanthesizedExpr + (from + EOW + WS + Name)?)
Nullable ::== (? + WS)
NumLiteral ::== (HexLiteral | BinaryLiteral | FloatLiteral | IntegerLiteral)
Param ::== (Name + TypeDecl?)
ParanthesizedExpr ::== (( + WS + (DelayedExpr + (, + WS + DelayedExpr)*)? + ) + WS)
RecordExpr ::== (record + EOW + WS + ArgList + { + WS + RecordFields + } + WS)
RecordFields ::== (DelayedExpr + (, + WS + DelayedExpr)*)?
ReduceExpr ::== (reduce + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + , + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + in + EOW + WS + DelayedExpr + ) + WS + DelayedExpr)
ReturnStatement ::== (return + EOW + WS + CompoundExpr? + ; + WS)
Row ::== ((DelayedExpr + (, + WS + DelayedExpr)*)? + Eos)
Rows ::== ({ + WS + Row* + } + WS)
SelectExpr ::== (select + EOW + WS + ( + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + from + EOW + WS + DelayedExpr + ) + WS + DelayedExpr)
SimpleWS ::== ([ \t] | EndOfLine)
SingleLineWS ::== ([ \t] | Comment)*
SpecialDelimiter ::== (forall + EOW + WS + WS)
SpecialName ::== ((null | true | false) + EOW + WS)
Statement ::== (CodeBlock | VarDecl | IfStatement | SwitchStatement | ForEachStatement | ForStatement | WhileStatement | ReturnStatement | DeleteStatement | ExprStatement | EmptyStatement)
StringCharLiteral ::== (EscapeChar | ([\n"]^ + AnyChar))
StringLiteral ::== (["] + StringCharLiteral* + ["])
SwitchStatement ::== (switch + EOW + WS + ParanthesizedExpr + { + WS + CaseGroup + DefaultStatement? + } + WS)
Symbol ::== [.~`!#$%^&*-+|:<>=?/]+
TableExpr ::== (table + EOW + WS + ArgList + Rows)
TypeArgs ::== (< + WS + TypeExpr + > + WS)
TypeDecl ::== (: + WS + TypeExpr + Nullable?)
TypeDefinition ::== (Class | Interface | Enum)
TypeExpr ::== (TypeName + WS + TypeArgs?)
TypeExprList ::== ({ + WS + (TypeExpr + ; + WS)* + } + WS)
TypeName ::== ((Ident + (. + WS + IdentFirstChar + IdentNextChar*)*) + WS)
UntilEndOfLine ::== AnyCharExceptEndOfLine*
UntilPastEndOfLine ::== (UntilEndOfLine + EndOfLine)
UpperCaseLetter ::== [A..Z]
VarDecl ::== (Annotations? + var + EOW + WS + (SpecialDelimiter^ + SpecialName^ + (Symbol | Ident)) + WS + TypeDecl? + Initializer? + ; + WS)
VerbStringCharLiteral ::== ("" | (["]^ + AnyChar))
VerbStringLiteral ::== (@" + VerbStringCharLiteral* + ["])
WhileStatement ::== (while + EOW + WS + ParanthesizedExpr + DelayedStatement)
WS ::== (SimpleWS | Comment)*
