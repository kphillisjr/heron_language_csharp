// Public domain, by Christopher Diggins
// http://www.cdiggins.com
//
// This files is for the construction of parse trees. Every AbstractNode in a parse tree is derived 
// from AbstractNode and provides access to the rule it represents through a function:
// virtual const type_info& GetRule(). Children are arranged by type. 
// Once you have the first child AbstractNode, you can repeatedly call GetSibling() to get the 
// next AbstractNode of the same type. 
//
// Parse trees are created automatically by inserting Store<T> productions into a grammar. 

#ifndef YARD_TREE_HPP
#define YARD_TREE_HPP

namespace yard
{   
	/////////////////////////////////////////////////////////////////////
	// Abstract Syntax Tree 

	// The AbstractNodes in a ParseTree are usually generated by adding Store<Rule_T> production rules		
	// to the grammar. The parser then responds by construction AbstractNodes in this tree.
	template<typename Iter_T>
	struct Ast
	{
		Ast(Iter_T begin) 
			: current(NULL), root(begin, NULL)
		{ 
			current = &root;
		}

		template<typename T>
		struct TypedNode;

		struct AbstractNode
		{
			// public types 
			typedef Iter_T TokenIter;     
		        
			// 'tors
			AbstractNode(TokenIter pos, AbstractNode* parent) 
			{  
				mpFirst = pos;
				mpLast = pos;
				mpNext = NULL;
				mpChild = NULL;
				mpLastChildPtr = &mpChild;
				mpParent = parent;
				mbCompleted = false;
			}		    
			virtual ~AbstractNode()
			{
				if (mpNext)
					delete mpNext;
				if (mpChild)
					delete mpChild;
			}
			void AddChild(AbstractNode* child)
			{
				assert(!IsCompleted());
				assert(mpNext == NULL);
				assert(*mpLastChildPtr == NULL);
				*mpLastChildPtr = child;
				mpLastChildPtr = &(child->mpNext);
			}    
			template<typename Rule_T>
			TypedNode<Rule_T>* NewChild(TokenIter pos)
			{
				//printf("%s\n", typeid(Rule_T).name());
				assert(!IsCompleted());
				TypedNode<Rule_T>* ret = new TypedNode<Rule_T>(pos, this);
				AddChild(ret);
				return ret;
			}  
			void DeleteChild(AbstractNode* p)
			{
				// This function only allows deletion of the last child
				// in a list.
				assert(p->mpNext == NULL);
				assert(&(p->mpNext) == mpLastChildPtr);
				assert(mpChild != NULL);

				if (p == mpChild) 
				{
					delete p;
					mpChild = NULL;
					mpLastChildPtr = &mpChild;				
				}
				else
				{
					// Start at first child
					AbstractNode* pBeforeLast = mpChild;					

					// iterate through siblings, until we reach the child before 
					// the last one
					while (pBeforeLast->mpNext != p)
					{
						pBeforeLast = pBeforeLast->mpNext;
						assert(pBeforeLast != NULL);
					}
					delete p;
					pBeforeLast->mpNext = NULL;
					mpLastChildPtr = &(pBeforeLast->mpNext);				
				}
			}
			bool HasChildren() 
			{
				return mpChild != NULL;
			}
			AbstractNode* GetFirstChild()
			{
				return mpChild;
			}
			bool HasSibling() 
			{
				return mpNext != NULL;
			}
			AbstractNode* GetSibling()
			{
				return mpNext;
			}
			template<typename T>
			bool TypeMatches()
			{
				return GetRuleTypeInfo() == typeid(T);
			}
			template<typename T>
			TypedNode<T>* GetTypedSibling()
			{
				AbstractNode* sib = GetSibling();
				while (sib != NULL)
				{
					if (sib->TypeMatches<T>())
						return dynamic_cast<TypedNode<T>*>(sib);
					sib = sib->GetSibling();
				}
				return NULL;
			}
			template<typename T>
			TypedNode<T>* GetFirstTypedChild()
			{
				AbstractNode* ret = GetFirstChild();
				if (ret == NULL) return NULL;
				if (ret->TypeMatches<T>()) return dynamic_cast<TypedNode<T>*>(ret);
				return ret->GetTypedSibling<T>();
			}
			AbstractNode* GetParent()
			{
				return mpParent;
			}
			void Complete(TokenIter pos) {      
				assert(!IsCompleted());
				mpLast = pos;      
				mbCompleted = true;
				assert(IsCompleted());
			}
			bool IsCompleted() {
				return mbCompleted;
			}    		    
			TokenIter GetFirstToken() {
				assert(IsCompleted());
				return mpFirst;
			}    
			TokenIter GetLastToken() {
				assert(IsCompleted());
				return mpLast;
			}
			template<typename F>
			void ForEach(const F& f)
			{
				for (Node* child = x->GetFirstChild(); child != NULL; child = child->GetSibling())
					f(child);
			}

			// abstract member functions
			virtual const type_info& GetRuleTypeInfo() = 0;
		    
		private:

			// fields
			bool mbCompleted;
			AbstractNode* mpParent;
			AbstractNode* mpChild;
			AbstractNode* mpNext;
			AbstractNode** mpLastChildPtr;
			TokenIter mpFirst;
			TokenIter mpLast;
		};	  

		template<typename Rule_T>
		struct TypedNode : AbstractNode
		{			
			TypedNode(TokenIter pos, AbstractNode* parent) 
				: AbstractNode(pos, parent)
			{  
			}

			virtual const type_info& GetRuleTypeInfo() {
				return typeid(Rule_T);
			}
		};

		// acccess the root AbstractNode
		AbstractNode* GetRoot() {
			return &root;
		} 
	    
		// CreateNode is called when an attempt is made to match a 
		// Store production rule
		template<typename Rule_T, typename ParserState_T>
		void CreateNode(ParserState_T& p) { 
			assert(current != NULL);
			typename ParserState_T::Iterator pos = p.GetPos();
			current = current->NewChild<Rule_T>(pos);
			assert(current != NULL);
		}

		// CreateNode is called when a Store production rule
		// is successfully matched 
		template<typename ParserState_T>
		void CompleteNode(ParserState_T& p) {
			assert(current != NULL);
			typename ParserState_T::Iterator pos = p.GetPos();
			current->Complete(pos);
			assert(current->IsCompleted());       
			current = current->GetParent();
			assert(current != NULL);
		}

		// AbandonNode is called when a Store<Rule_T> production rule
		// fails to match
		template<typename ParserState_T>
		void AbandonNode(ParserState_T& p) {    
			assert(current != NULL);
			AbstractNode* tmp = current;
			assert(!tmp->IsCompleted());
			current = current->GetParent();
			assert(current != NULL);
			current->DeleteChild(tmp);
		}

		// deletes the current tree. 
		void Clear() {
			assert(current == &root);
			root.Clear();
		}
	    
	private:
		 
		TypedNode<void> root;       
		AbstractNode* current; 
	};
}

#endif 
