domain Demo {

  imports {
    Math;
    Drawing2D;
    Keyboard;
  }

  attributes {
    painter : Painter;
    shooter : Shooter;
    boxLeft : int;
    boxTop : int;
    boxWidth : int;
    boxHeight : int;
    walls : Collection<Wall>;
    balls : Collection<Ball>;
  }

  operations {
    initialize() {
      boxLeft = 100;
      boxTop = 100;
      boxWidth = 200;
      boxHeight = 200;
      var x0 : int = boxLeft;
      var y0 : int = boxTop;
      var x1 : int = x0 + boxWidth;
      var y1 : int = y0 + boxHeight;
      walls = new Collection<Wall>();
      balls = new Collection<Ball>();
      shooter = new Shooter(0, 10, 10);
      walls.add(new Wall(x0,y0,x1,y0));
      walls.add(new Wall(x1,y0,x1,y1));
      walls.add(new Wall(x1,y1,x0,y1));
      walls.add(new Wall(x0,y1,x0,y0));
      balls.add(new Ball(new Point(200,200), new Vector(200,120), 10));
      balls.add(new Ball(new Point(150,150), new Vector(100,60), 15));
      balls.add(new Ball(new Point(250,150), new Vector(-50,-5), 20));
      balls.add(new Ball(new Point(250,250), new Vector(-100,0), 25));
      balls.add(new Ball(new Point(150,250), new Vector(0,100), 30));
      painter = new Painter();
      registerKeyListener(painter);
      painter.generateNextEvent();
    }
    boxCenter() : Point {
      return new Point(boxLeft + (boxWidth / 2), botTop + (boxHeight / 2));
    }
    distance(first : Point, second : Point) : Real {
      return sqrt(sqr(first.x - second.x) + sqr(first.y - second.y));
    }
    sqrt(x : Real) : Real {
      return Math.sqrt(x);
    }
    sqr(x : Real) : Real {
      return x * x;
    }
    sin(x : Real) : Real {
      return Math.sin(x);
    }
    cos(x : Real) : Real {
      return Math.cos(x);
    }
    acos(x : Real) : Real {
      return Math.acos(x);
    }
    min(x : Real, y : Real) : Real {
      return Math.min(x, y);
    }
    floor(x : Real) : int {
      return (int)Math.floor(x);
    }
    updateBallPositions(elapsedMSec : Real) {
      foreach (ball : Ball in Demo.balls) {
        ball.updatePosition(elapsedMSec);
      }
    }
  }

  classes {
    class Point {
      attributes {
        x : Real;
        y : Real;
      }
      operations {
        constructor(x : Real, y : Real) {
          this.x = x;
          this.y = y;
        }
        translate(v : Vector) : Point {
          return new Point(x + v.x, y + v.y);
        }
        difference(pt : Point) : Vector {
          return new Vector(pt.x - x, pt.y - y);
        }
        distance(pt : Point) : Real {
          return difference(pt).length();
        }
        asVector() : Vector {
          return new Vector(x, y);
        }
        rotate(pt : Point, th : Real) : Point {
          var x1 : Real = x * Demo.cos(th) - y * Demo.sin(th);
          var y1 : Real = x * Demo.sin(th) + y * Demo.cos(th);
          return new Point(x1, y1);
        }
      }
    }

    class Vector {
      attributes {
        x : Real;
        y : Real;
      }
      operations {
        constructor(x : Real, y : Real) {
          this.x = x;
          this.y = y;
        }
        constructor(line : Line) {
          this.x = line.begin.x - line.end.x;
          this.y = line.begin.y - line.end.y;
        }
        add(v : Vector) : Vector {
          return new Vector(x + v.x, y + v.y);
        }
        sub(v : Vector) : Vector {
          return new Vector(v.x - x, v.y - y);
        }
        scale(s : Real) : Vector {
          return new Vector(x * s, y * s);
        }
        dot(v : Vector) : Real {
          return x * v.x + y * v.y;
        }
        normal() : Vector {
          return new Vector(-y, x);
        }
        normalize() : Vector {
          return new Vector(x / length(), y / length());
        }
        length() : Real {
          return Demo.sqrt(Demo.sqr(x) + Demo.sqr(y));
        }
        theta(v : Vector) : Real {
          return Demo.acos(dot(v) / (length() * v.length()));
        }
        tangent() : Vector {
          return new Vector(y, -x);
        }
        proj(v : Vector) : Vector {
          return v.scale(dot(v) / Demo.sqr(v.length()));
        }
      }
    }

    class Line {
      attributes {
        begin : Point;
        end : Point;
      }
      operations {
        constructor(x0 : Real, y0 : Real, x1 : Real, y1 : Real) {
          begin = new Point(x0, y0);
          end = new Point(x1, y1);
        }
        length() : Real {
          return Demo.distance(begin, end);
        }
      }
    }

    class Wall {
      attributes {
        line : Line;
      }
      operations {
        constructor(x0 : Real, y0 : Real, x1 : Real, y1 : Real) {
          line = new Line(x0, y0, x1, y1);
        }
      }
    }
    
    class Shooter {
	  attributes {
	    angle : Real; 
	    length : Real;
	    width : Real;
	  }	  	  
	  operations {
	    construct(angle : Real, length : Real, width : Real) {
	      this.angle = angle;
	      this.length = length;
	      this.width = width;
	    }	    
	    getPoints() : Collection<Point> {
		  var result : Collection<Point> = new Collection<Point>();
		  var pt1 : Point = new Point(-(width / 2), length / 2);
		  var pt2 : Point = new Point(width / 2, length / 2);
		  var pt3 : Point = new Point(0, -(length / 2));		  
		  result.Add(pt1);
		  result.Add(pt2);
		  result.Add(pt3);
		  return result;
	    }
	  }
    }
    
    class Ball {
      attributes {
        pos : Point;
        vec : Vector;
        radius : Real;
      }
      operations {
        constructor(pos : Point, vec : Vector, radius : Real) {
          this.pos = pos;
          this.vec = vec;
          this.radius = radius;
        }
        computeWallCollisionEvent(wall : Wall) : BallWallCollisionEvent {
          var x0 : Real = pos.x;
          var y0 : Real = pos.y;
          var xt : Real = vec.x;
          var yt : Real = vec.y;
          var x1 : Real = wall.line.begin.x;
          var y1 : Real = wall.line.begin.y;
          var x2 : Real = wall.line.end.x;
          var y2 : Real = wall.line.end.y;
          var den : Real = Demo.sqrt(Demo.sqr(x2 - x1) + Demo.sqr(y2 - y1));
          var dx : Real = x2 - x1;
          var dy : Real = y2 - y1;

          var t1 : Real = ((radius * den) - (dx * y1) + (dx * y0) + (dy * x1) - (dy * x0)) 
			/ (-dx * yt + dy * xt);
          var t2 : Real = (-(radius * den) - (dx * y1) + (dx * y0) + (dy * x1) - (dy * x0)) 
			/ (-dx * yt + dy * xt);
			
          var t : Real = Demo.min(t1, t2);
          
          if (t1 <= 0.0) {
            if (t2 <= 0.0) 
              return null; else 
              t = t2;
          }
          else {
            if (t2 < 0) 
              t = t1; else 
              t = Demo .min (t1 , t2 ) ;
          }
          return new BallWallCollisionEvent(Demo.floor(t * 1000), this, wall);
        }
        computeBallCollisionEvent(ball : Ball) : BallBallCollisionEvent {           
        	// dist = (x1 - x2)(x1 - x2) + (y1 - y2)(y1 - y2)
			// dist = (x1 x1) - 2*x1*x2 + (x2*x2) + ...
			// var ax : Real = x1 * x1;
			// var bx : Real = -2 * x1 * x2;
			// var cx : Real = x2 * x2;			
			// var dy : Real = y1 * y1;
			// var ey : Real = -2 * y1 * y2;
			// var fy : Real = y2 * y2;
			// x1 = ox1 + t*dx1
			// x2 = ox2 + t*dx2
			// y1 = oy1 + t*dy1
			// y2 = oy2 + t*dy2
			// ax = ox1^2 + 2*t*ox1*dx1 + t^2*dx1^2
			// bx = -2*ox1*ox2 - 2*t*dx1*ox2 - 2*ox1*t*dx2 - 2*t^2*dx1*dx2)
			// cx = ox2^2 + 2*t*ox2*dx2 + t^2*dx2^2
			// dy = oy1^2 + 2*t*oy1*dy1 + t^2*dy1^2
			// ey = -2*oy1*oy2 - 2*t*dy1*oy2 - 2*oy1*t*dy2 - 2*t^2*dy1*dy2)
			// fy = oy2^2 + 2*t*oy2*dy2 + t^2*dy2^2
			// dist = ax + bx + cx + dy + ey + fy;

			var ox1 : Real = pos.x;
			var oy1 : Real = pos.y;
			var ox2 : Real = ball.pos.x;
			var oy2 : Real = ball.pos.y;
			var dx1 : Real = vec.x;
			var dy1 : Real = vec.y;
			var dx2 : Real = ball.vec.x;
			var dy2 : Real = ball.vec.y;
						
			dist = radius + ball.radius;
			
			// dist = a*x^2 + b*x + c						
			var a : Real = sqr(dx1) - 2*dx1*dx2 + sqr(dx2) + sqr(dy1) - 2*dy1*dy2 + sqr(dy2);
			var b : Real = -2*dx1*ox2 - 2*ox1*dx2 + 2*ox2*dx2 + 2*oy1*dy1 - 2*dy1*oy2 - 2*oy1*dy2
			var c : Real = sqr(ox1) - 2*ox1*ox2 + ox2*ox2 + oy1*oy1 - 2*oy1*oy2 + oy2*oy2;
			
			c = c - dist;

			if (a == 0.0) 
				return null;

			var b24ac : Real = sqr(b) - 4*a*c;						
			
			if (b24ac < 0.0) 
				return null;
			
			var t1 : Real = (-b + sqrt(b24ac)) / (2 * a);
			var t2 : Real = (-b - sqrt(b24ac)) / (2 * a);
			
			if (t1 <= 0.0) {
			  if (t2 <= 0.0) 
			    return null; else 
			    t = t2;
			}
			else {
			  if (t2 < 0) 
			    t = t1; else 
			    t = Demo .min (t1 , t2 ) ;
            }
		    return new BallWallCollisionEvent(Demo.floor(t * 1000), this, wall);								
        }
        computeCollisionEvents() : Collection<CollisionEvent> {
          var result : Collection<CollisionEvent> = new Collection<CollisionEvent>();
          foreach (wall : Wall in Demo.walls) {
            CollisionEvent collision = computeWallCollisionEvent(wall);
            if (collision != null) {
              result.add(collision);
            }
          }
          foreach (ball : Ball in Demo.balls) {
            if (ball != this) {
              CollisionEvent collision = computeBallCollisionEvent(ball);
              if (collision != null) {
                result.add(collision);
              }
            }
          }
          return result;
        }
        bounceOffWall(wall : Wall) {
            var w : Vector = new Vector(wall.line);
            var n : Vector = w.normal();
            var pn : Vector = vec.proj(n);
            var pw : Vector = vec.proj(w);
            var r : Vector = pn.scale(-1.0).add(pw);
            vec.x = r.x;
            vec.y = r.y;
        }
        // Alternatively, this could be implemented as a state.         
        updatePosition(elapsedMSec : Real) {
          pos = pos.translate(vec.scale(elapsedMSec / 1000.0));
        }
      }
    }
    
    class CollisionEvent {
	  attributes {
        timeElapsed : Real;
      }
    }
    
    class BallBallCollisionEvent {
      subclasses {
        CollisionEvent;
      }
      attributes {
        ball1 : Ball;
        ball2 : Ball;
      }
      operations {
        constructor(timeElapsed : Real, ball1 : Ball, ball2 : Ball) {
          this.timeElapsed = timeElapsed;
          this.ball1 = ball1;
          this.ball2 = ball2;
        }
      }
    }
    
    class BallWallCollisionEvent {
      subclasses {
        CollisionEvent;
      }
      attributes {
        ball : Ball;
        wall : Wall;
      }
      operations {
        constructor(timeElapsed : Real, ball : Ball, wall : Wall) {
          this.timeElapsed = timeElapsed;
          this.ball = ball;
          this.wall = wall;
        }
      }
    }

    class PaintEvent {
      attributes {
        timeElapsed : Real;
      }
      operations {
        constructor(timeElapsed : Real) {
          this.timeElapsed = timeElapsed;
        }
      }
    }

    class Painter {
      attributes {
        paintFrequency : Real;
        timeToNextPaint : Real;
      }
      operations {
        constructor() {
          paintFrequency = 50.0;
          timeToNextPaint = paintFrequency;
        }
        generateNextEvent()  {
          generateNextEvent(null, null);
        }        
        generateNextEvent(lastBall : Ball, lastWall : Wall)  {
          var next : CollisionEvent;
          var q : Collection<CollisionEvent> = new Collection<CollisionEvent>();

          // Compute all possible CollisionEvents
          q.clear();
          foreach (ball : Ball in Demo.balls) {
            q.concat(ball.computeCollisionEvents());
          }

          // Exclude last ball/wall CollisionEvent
          q.filter((x : CollisionEvent)
            => { return (x.ball != lastBall) || (x.wall != lastWall); });

          // Get the next earliest CollisionEvent
          next = q.min((x : CollisionEvent) => { return x.timeElapsed; });

          if (next != null) {
            if (next.timeElapsed < timeToNextPaint) {
              timeToNextPaint = timeToNextPaint - next.timeElapsed;
              this.sendIn(next, (int)next.timeElapsed);
            }
            else {
              this.sendIn(new PaintEvent(timeToNextPaint), (int)timeToNextPaint);
            }
          }
          else {
            Demo.error("could not compute next collision");
          }
        }
        drawShooter() {
          // Note: a "fold" function would be more elegant
          var pts : Collection<Point> = Demo.shooter.getPoints();
          var origin : Point = new Point(0, 0);
          
          // Rotates points about origin
          pts = pts.map(
		    (pt : Point) => { 
		       return pt.rotate(origin, Demo.shooter.angle); 
		     });
		     
		  // Translate points to center of box
          pts = pts.map(
            (pt : Point) => { 
              return pt.translate(Demo.getBoxCenter());
            });            
          
          var i : int = 1;
          while (i < pts.Count) {
            var pt1 : Point = pts.getAt(i - 1);
            var pt2 : Point = pts.getAt(i);              
            Demo.drawLine(pt1.x, pt1.y, pt2.x, pt2.y);
            ++i;
          }
          if (pts.Count > 1) {
            var pt1 : Point = pts.getAt(0);
            var pt2 : Point = pts.getAt(pts.Count - 1);
            Demo.drawLine(pt1.x, pt1.y, pt2.x, pt2.y);
          }
        }
      }
      states {
        initial() {
          transitions {
            BallWallCollisionEvent -> onBallWallCollision;
            BallBallCollisionEvent -> onBallBallCollsion;
            PaintEvent -> onPaint;
            KeyboardEvent -> onKeyboard;
          }
        }
        onCollision(col : CollisionEvent) {
          entry {
            Demo.updateBallPositions(col.timeElapsed);
            col.ball.bounceOffWall(col.wall);
            generateNextEvent(col.ball, col.wall);
          }
          transitions {
			auto -> initial;
          }
        }
        onPaint(evt : PaintEvent)  {
          entry {
            timeToNextPaint = paintFrequency;
            Demo.clear();
            Demo.updateBallPositions(evt.timeElapsed);

            foreach (wall : Wall in Demo.walls) {
              Demo.drawLine(wall.line.begin.x, wall.line.begin.y, wall.line.end.x, wall.line.end.y);
            }

            foreach (ball : Ball in Demo.balls) {
              Demo.drawCircle(ball.pos.x, ball.pos.y, ball.radius);
            }
            
			drawShooter();            
            Demo.render();
            generateNextEvent();
          }
          transitions {
            auto -> initial;
          }
        }
        onKey(evt : KeyEvent) {
          entry {
            if (evt.Key == Keyboard.LeftArrow) {
              Demo.shooter.TurnLeft();
            }
            else if (evt.Key == Keyboard.RightArrow) {
              Demo.shooter.TurnRight();
            }
            else if (evt.Key == Keyboard.Space) {
              Demo.shooter.Shoot();
            }            
          }
          transitions {
		    auto -> initial;
          }
        }
      }
    }
  }
}