domain Demo
{
  imports {
    Math;
    Graphics;
  }

  operations {
    initialize() {
      var x0 : int = 5;
      var y0 : int = 5;
      var x1 : int = 195;
      var y1 : int = 195;
      new Wall(x0,y0,x1,y0);
      new Wall(x1,y0,x1,y1);
      new Wall(x1,y1,x0,y1);
      new Wall(x0,y1,x0,y0);
      new Ball(new Point(100,100), new Vector(20,10), 10);
      var painter : Painter = new Painter();
      painter.send(new PaintEvent(100));
    }

    distance(first : Point, second : Point) : Real {
      return sqrt(sqr(first.x - second.x) + sqr(first.y - second.y));
    }
    sqrt(x : Real) : Real {
      return Math.sqrt(x);
    }
    sqr(x : Real) : Real {
      return x * x;
    }
    acos(x : Real) : Real {
      return Math.acos(x);
    }
  }

  classes {
    class Point {
      attributes {
        x : Real;
        y : Real;
      }
      operations {
        constructor(x : Real, y : Real) {
          this.x = x;
          this.y = y;
        }
        translate(v : Vector) : Point {
          Point result = new Point(x + v.x, y + v.y);
          return result;
        }
        difference(pt : Point) : Vector {
          return new Vector(pt.x - x, pt.y - y);
        }
        distance(pt : Point) : Real {
          return difference(pt).length();
        }
        asVector() : Vector {
          return new Vector(x, y);
        }
      }
    }

    class Vector {
      attributes {
        x : Real;
        y : Real;
      }
      operations {
        constructor(x : Real, y : Real) : Vector {
          this.x = x;
          this.y = y;
        }
        add(v : Vector) : Vector {
          return new Vector(x + v.x, y + v.y);
        }
        scale(s : Real) : Vector {
          return new Vector(x * s, y * s);
        }
        dot(v : Vector) : Real {
          return x * v.x + y * v.y;
        }
        length() : Real {
          return Demo.sqrt(Demo.sqr(x) + Demo.sqr(y));
        }
        theta(v : Vector) : Real {
          return Demo.acos(dot(v) / (length() * v.length()));
        }
        tangent() : Vector {
          return new Vector(y, -x);
        }
      }
    }

    class Line {
      attributes {
        begin : Point;
        end : Point;
      }
      operations {
        constructor(x0 : Real, y0 : Real, x1 : Real, y1 : Real) {
          begin = new Point(x0, y0);
          end = new Point(x1, y1);
        }
        length() : Real {
          return Demo.distance(begin, end);
        }
      }
    }

    class Wall {
      attributes {
        line : Line;
      }
      operations {
        constructor(x0 : Real, y0 : Real, x1 : Real, y1 : Real) {
          line = new Line(x0, y0, x1, y1);
        }
      }
    }

    class Ball {
      attributes {
        pos : Point;
        // Note: the type should encode the units
        vec : Vector;
        radius : Real;
      }
      operations {
        constructor(pos : Point, vec : Vector, radius : Real) {
          this.pos = pos;
          this.vec = vec;
          this.radius = radius;
        }
        computeCollision(wall : Wall) : Collision
        {
          var num : Real = abs((x2 - x1) * (y1 - t * y0) - (x1 - t * x0) * (y2 - y1))
          var den : Real = sqrt(sqr(x2 - x1) + sqr(y2 - y1));
          var dist : Real = num / den;

          /*
          From: http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html

          abs((x2 - x1) * (y1 - t * y0) - (x1 - t * x0) * (y2 - y1)) / sqrt(sqr(x2 - x1) + sqr(y2 - y1)) = rad;
          abs((x2 - x1) * (y1 - t * y0) - (x1 - t * x0) * (y2 - y1)) = rad * sqrt(sqr(x2 - x1) + sqr(y2 - y1))
          let dx = x2 - x1;
          let dy = y2 - y1;
          abs((dx) * (y1 - t * y0) - (x1 - t * x0) * (dy)) = rad * sqrt(sqr(dx) + sqr(dy))
          let den = sqrt(sqr(dx) + sqr(dy))
          abs((dx) * (y1 - t * y0) - (x1 - t * x0) * (dy)) = rad * den
          +/-((dx) * (y1 - t * y0) - (x1 - t * x0) * (dy)) = rad * den
          (dx) * (y1 - t * y0) - (x1 - t * x0) * (dy) = +/-(rad * den);
          ((dx * y1) - (t * y0 * dx)) - ((dy * x1) - (t * x0 * dy) = +/-(rad * den);
          (dx * y1) - (t * y0 * dx) - (dy * x1) + (t * x0 * dy) = +/-(rad * den);
          - (t * y0 * dx) + (t * x0 * dy) = +/-(rad * den) - (dx * y1) + (dy * x1) ;
          let ydx = y0 * dx;
          let xdy = x0 * dy;
          - (t * ydx) + (t * xdy) = +/-(rad * den) - (dx * y1) + (dy * x1) ;
          t * (-ydx + xdx) = +/-(rad * den) - (dx * y1) + (dy * x1) ;
          t = (+/-(rad * den) - (dx * y1) + (dy * x1)) / (-ydx + xdx)
          */

          // solve for t and dist = rad

          return null;
        }
        computeCollisions() : Collection<Collision> {
          Collection<Collision> result = new Collection<Collision>();
          foreach (ball : Ball in Ball.instances) {
            result.add(computeCollision(ball));
          }
          foreach (wall : Wall in Wall.instances) {
            result.add(computeCollision(wall));
          }
          return result;
        }
        updatePosition(elapsedMSec : Real) {
          pos = pos.translate(vec.scale(elapsedMSec / 1000.0));
        }
      }
    }

    class Box {
      attributes {
        walls : Collection;
      }
      links {
        walls : R1<Wall>;
      }
      invariants {
        // NOTE: invariants are not yet verified
        fourWalls {
          return walls.count() == 4;
        }
      }
    }

    class Collision {
      attributes {
        time : int;
        target1 : Ball;
        target2 : Wall;
      }
    }

    class CollisionManager {
      operations {
        generateNextCollision() : Collision {
          var next : Collision;
          var q : Collection<Collision> = new Collection<Collision>();
          q.clear();
          foreach (ball : Ball in Ball.instances) {
            q.concat(ball.computeCollisions());
          }
          next = q.min((x : Collision) => { return x.time; });
          this.sendIn(col, next.time);
        }
      }
      states {
        initial() {
          transitions {
            Collision -> painting;
          }
        }
        onCollision(col : Collision) {
          entry {
            // TODO: Respond to collisions

            generateNextCollision();
          }
          transitions {
            Collision -> onCollision;
          }
        }
      }
    }

    // Should there be a differentiation between events and other kinds of classes?
    // As far as I can tell: no.
    // Except for the fact there are some problems with "instances".
    class PaintEvent {
      attributes {
        frequency : int;
      }
      operations {
        constructor(freq : int) {
          frequency = freq;
        }
      }
    }

    class Painter {
      states {
        initial() {
          transitions {
            PaintEvent -> painting;
          }
        }
        painting(evt : PaintEvent)  {
          entry {
            Demo.clear();

            foreach (wall : Wall in Wall.instances) {
              Demo.drawLine(wall.line.begin.x, wall.line.begin.y, wall.line.end.x, wall.line.end.y);
            }

            foreach (ball : Ball in Ball.instances) {
              ball.updatePosition(evt.frequency);
              Demo.drawCircle(ball.pos.x, ball.pos.y, ball.radius);
            }

            Demo.render();

            // Resend same signals
            this.sendIn(evt, evt.frequency);
          }
          transitions {
            PaintEvent -> painting;
          }
        }
      }
    }
  }
}